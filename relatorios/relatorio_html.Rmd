---
title: "Como funciona o Algoritmo"
author: "Pedro Loes"
date: "02/02/2021"
output: ioslides_presentation
---

##  Problema

* Descrição:
  * Função:
    * Minimizar o número de pontos de acesso (PA's) na área de 800 x 800 que atendam à demanda de 475 clientes (PD's).
  * Restrições:
    * A soma da demanda dos PD's cobertos por um dado PA não deve ultrapassar 150 Mbps.
    * O número de PA's não deve ultrapassar 100.

## Espaço de busca

* Escala:
  * Continua:
    * Existem infinitas coordenadas de possíveis localizações para os PA's e o problema é computacionalmente isolúvel. 
  
  * Discreta:
    * Considerando a área de 800 x 800 como inteiros 640.000 possíveis localizações para os PA's e o problema já permite um tratameto computacional.
 
## Desenho do Algoritmo 
 
* Testes:
  * Espaços discretos menores que 8 x 8 não apresentaram solução ótima.
  * Espaços maiores que 150 x 150 apresentaram custo computacional muito elevado.
   
* Implementação:    
  * O algorítimo foi desenhado para escanear os espaços discretos de 8 x 8 até 150 x 150 na área de 800 x 800 com intervalos iguais entre os pontos.
  * Para ilustrar foi considerado o espaço de 9 x 9 que representa 81 possíveis localizações para os PA's.

##

```{r,  warning=F, echo = F, message=F, error=F, fig.align="center", fig.width=7, fig.height=6}

# Carrega Bibliotecas
library(tidyverse)
library(plotly)

# Declara possíveis posições para os pontos de acesso
centro_x <- rep(c(0,100,200,300,400,500,600,700,800), times = 9)  
centro_y <- rep(c(0,100,200,300,400,500,600,700,800), each = 9) 

# Declara data frame do grid
grid_9_9 <- tibble(x = centro_x,
                   y = centro_y)

# gráfico das posições
plot_ly(data = grid_9_9,
       x = ~x,
       y = ~y) %>% 
  add_markers(size = 3,
              color = "red",
  ) %>% 
  layout(title = list(text = 'Espaço Discretizado 9 x 9')) %>% 
  config(displayModeBar = F)



```


## Interações do Algoritmo 

* Laço:
  * A cada iteração o algoritmo inspeciona cada coordenada do espaço discretizado de possíveis localizações dos PA's e determina o PA que cobre o maior número de PD's. 
  * O indice do PA com maior cobertura de PD's é armazenado e esses PD's são removidos.
  * O algorítmo reinicia a busca do próximo PA que cobre mais PD's dentre os restantes.

* Critério de Parada:
  * O algoritmo para quando cobre pelo menos 475 dos 500 PD's atendendo as restrições de consumo de banda e limite de PA's.

## Primeira Iteração

* O algoritmo conta o número de PD's cobertos por cada uma das 81 possíveis localizações para o 1º PA.

* O PA nas coordenadas (200, 200) cobre o maior número de PD's.

* As coordenadas deste 1º PA são armazenadas.

* Os 202 PD's cobertos por este PA são removidos.

##

```{r, warning=F, echo = F, message=F, error=F, fig.align="center", fig.width=7, fig.height=6}

# Importa dados
wlan_completa <- read_csv("https://raw.githubusercontent.com/Protospi/WLAN/main/dados/clientes.csv",
                          col_names = c("x", "y", "Mbps"))

# Insere colunas de indice
wlan1 <- wlan_completa %>%
  mutate(indice = 1:nrow(wlan_completa))

# Declara vetor que armazena resultasdos
contagem1 <- numeric(81)

# Limite 
limite <- 85^2

# Laco para determinar maior contagem
for(i in 1:81){
  
  # Declara total
  total1 = 0
  
  # Laco para pontos
  for(j in 1:500){
    
    # Calcula soma da diferenca de quadrados
    dist1 <-  (wlan1$x[j] - centro_x[i])^2 + (wlan1$y[j] - centro_y[i])^2 
    
    # Condicao de pertenciamento ai raio da wlan
    if(dist1 <= limite){
      
      # Incrementa total de Pd's
      total1 <- total1 + 1
      
    }
    
  }
  
  # Popula Pa's
  contagem1[i] <- total1
  
}

# Carrega dados
wlan1 <- tibble(Pa = rep(1,500)) %>%
  bind_cols(read_csv("https://raw.githubusercontent.com/Protospi/WLAN/main/dados/clientes.csv",
                     col_names = c("x", "y", "consumo")))

# primeiro grid
grid1 <- tibble(Pa = 2:82,
               x = rep(c(0,100,200,300,400,500,600,700,800), times = 9),
               y = rep(c(0,100,200,300,400,500,600,700,800), each = 9),
               consumo = rep(100, 81),
               Pd = contagem1)

base1 <- wlan1 %>%
  plot_ly(x = ~x, 
          y = ~y,
          size = ~consumo,
          type = "scatter",
          alpha = 0.8,
          name = "Pontos de Demanda") %>% 
  add_markers(
    showlegend = F,
    alpha = 0.3,
    alpha_stroke = 0.3,
    marker=list(color = 'rgb(0,191,255)'),
    name = "Pontos de Demanda",
  ) %>%
  add_markers(frame = ~paste0(sprintf("%02d", Pa-1), " = ", Pd),
              marker=list(sizeref=0.035,
                          sizemode="area",
                          color = 'rgb(255,140,0)'),
              alpha= 0.01,
              data = grid1,
              name = "Pontos de Acesso") %>%
  animation_opts(500,  transition = 1, easing = "exp-out") %>% 
  animation_slider(
    currentvalue = list(prefix = "Pa: ")
  ) %>% 
  layout(legend = list(x = 100, y = 0.5),
         title = list(text = 'Primeira Iteração')) %>% 
  config(displayModeBar = F)

# Executa
base1

```


## Segunda Iteração

* O algoritimo realiza a mesma busca da primeira iteração porém desconsiderando os PD's cobertos pelo 1º PA.

* O PA nas coordenadas (600, 600) cobre o maior número de PD's.

* Da mesma forma são armazenadas as coordenadas desse 2º PA. 

* Os 199 PD's cobertos por este PA também são removidos.

## 

```{r, warning=F, echo = F, message=F, error=F, fig.align="center", fig.width=7, fig.height=6}

# Recupera indices
indices1 <- NULL

# Laco para pontos
for(j in 1:500){
  
  # Calcula soma da diferenca de quadrados
  dist1 <- (wlan1$x[j] - centro_x[21])^2 + (wlan1$y[j] - centro_y[21])^2 
  
  # Condicao de pertenciamento ai raio da wlan
  if(dist1 <= limite){
    
    # Incrementa total de Pd's
    indices1 <- c(indices1, j)
    
  }
  
}

# --------------------------------------------------------------------------

# Carrega dados depois da primeira remocao
wlan2 <- wlan1[-indices1,]

# --------------------------------------------------------------------------

# Declara vetor que armazena resultasdos
contagem2 <- numeric(81)

# Laco para determinar maior contagem
for(i in 1:81){
  
  # Declara total
  total2 = 0
  
  # Laco para pontos
  for(j in 1:nrow(wlan2)){
    
    # Calcula soma da diferenca de quadrados
    dist2 <-  (wlan2$x[j] - centro_x[i])^2 + (wlan2$y[j] - centro_y[i])^2 
    
    # Condicao de pertenciamento ai raio da wlan
    if(dist2 <= limite){
      
      # Incrementa total de Pd's
      total2 <- total2 + 1
      
    }
    
  }
  
  # Popula Pa's
  contagem2[i] <- total2
  
}

# --------------------------------------------------------------------------

# primeiro grid
grid2 <- tibble(Pa = 2:82,
               x = rep(c(0,100,200,300,400,500,600,700,800), times = 9),
               y = rep(c(0,100,200,300,400,500,600,700,800), each = 9),
               consumo = rep(100, 81),
               Pd = contagem2)

# --------------------------------------------------------------------------

base2 <- wlan2 %>%
  plot_ly(x = ~x, 
          y = ~y,
          size = ~consumo,
          type = "scatter",
          alpha = 0.8,
          name = "Pontos de Demanda") %>% 
  add_markers(
    showlegend = F,
    alpha = 0.3,
    alpha_stroke = 0.3,
    marker=list(color = 'rgb(0,191,255)'),
    name = "Pontos de Demanda",
  ) %>%
  add_markers(frame = ~paste0(sprintf("%02d", Pa-1), " = ", Pd),
              marker=list(sizeref=0.035,
                          sizemode="area",
                          color = 'rgb(255,140,0)'),
              alpha= 0.01,
              data = grid2,
              name = "Pontos de Acesso") %>%
  animation_opts(500,  transition =1, easing = "exp-out") %>%
  animation_slider(
    currentvalue = list(prefix = "Pa: ")
  ) %>% 
  layout(legend = list(x = 100, y = 0.5),
         title = list(text = 'Segunda Iteração'))%>% 
  config(displayModeBar = F)

# Executa grafico
base2

```


## Decima Sétima Iteração

* O algoritmo para. 

* Os critérios são atendidos.

* O resultado da busca retorna uma solução no mínimo local de 17 PA´s. 

## 

![](https://raw.githubusercontent.com/Protospi/WLAN/main/imagens/solucao_9x9.png)


## Observações:

* O mínimo global foi encontrado a partir de espaços discretos de 55 x 55.

* Ente espaços discretos de 55 x 55 até aproximadamente 125 x 125 o algoritmo oscila entre 12 e 13 PA's.

* Nos espaços discretos mais granulares que 125 x 125 o algoritmo converge para o mínimo global de 12 PA's.


